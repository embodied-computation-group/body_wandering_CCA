---
title: "MDIES_validitiy_reliability"
output: html_document
date: "2025-02-19"
---


**Import post-resting-state mind-wandering data**
```{r, message=FALSE}

# clean slate to be sure
rm(list = ls())

# check for pacman package and install if not found
if (!require("pacman")) install.packages("pacman")
  pacman::p_load(readr,psych,polycor,corrplot,lattice,nFactors,GPArotation,EFA.dimensions,dplyr, tidyverse, here, circlize, BiocManager, ComplexHeatmap, reshape2, ggcorplot, R.matlab)

rest_probes <- read_csv("/home/leah/Git/BodyWanderingCCA/data/rest_probes.csv")
rest_probes <- na.omit(rest_probes)
rest_probes <- apply(as.matrix(rest_probes[ ,2:ncol(rest_probes)]), 2, as.numeric) #convert to numeric matrix

hist(rest_probes)

```


**Test assumptions of rest mind-wandering data for EFA**
```{r}
# Watkins et al., 2018 https://journals.sagepub.com/doi/full/10.1177/0095798418771807
# view correlation matrix of items (needs relatively high correlations among items for FA)
# sizable number of correlations should exceed ±.30

sample_size = sum(complete.cases(rest_probes))

# Correlation plots
cormatrix = hetcor(rest_probes)$correlations
corrplot(cormatrix, method="circle", addrect = 0,
         title = "RestProbes", mar = c(0,0,1,0),tl.cex=0.9) 


# Bartlett’s Test of Sphericity (relationship strength/multivariate normality)
# ^statistically significant chi-square value to justify the application of EFA.
cortest.bartlett(cormatrix,sample_size)

# Kaiser-Meyer-Olkin test for sampling adequacy
# Overall KMO values ≥.70 are desired, values less than .50 are generally considered unacceptable
KMO(cormatrix)

# remove spontaneous as KMO <.5
rest_probes = subset(rest_probes, select = -c(Spontaneous))

# run tests again without spontaneous item
cormatrix = hetcor(rest_probes)$correlations
cortest.bartlett(cormatrix,sample_size)
KMO(cormatrix)

# Internal Reliability of MDIES
reliability <- psych::alpha(rest_probes, check.keys=TRUE)
cat("Cronbach's Alpha (Raw):", reliability$total$raw_alpha, "\n")
cat("Cronbach's Alpha (Standardized):", reliability$total$std.alpha, "\n")

omega_results <- psych::omega(rest_probes)
cat("Omega Total (ωt):", omega_results$omega.tot, "\n")

```


**Determine number of factors**
```{r, message=FALSE}

# Minimum Average Partial (MAP) test
MAP_results = MAP(rest_probes, corkind='pearson', verbose=FALSE)
sprintf("MAP recommends %s (1976) or %s (2000) factors",MAP_results$NfactorsMAP,MAP_results$NfactorsMAP4) #MAP_results$NfactorsMAP (1976 MAP test), MAP_results$NfactorsMAP4 (revised 2000 MAP test)

```


# conduct EFA, oblimin, principal axis
```{r}
colnames(rest_probes)[colnames(rest_probes) == "Ruminate"] <- "Repetitive" #rename as requested by reviewer

fa.restResults =fa(
  (hetcor(rest_probes)$correlations), 
  nfactors = MAP_results$NfactorsMAP4, # MAP (2000) suggests 2
  n.obs=sample_size, #specify number of observations 
  rotate = "oblimin",
  max.iter=500, # (50 is default)
  fm="pa") # Principal axis doesn't make distribution assumptions ("ml" does)

print(fa.restResults)
print(fa.restResults$Vaccounted)
fa.diagram(fa.restResults)


# Fit indices
chi_sq <- fa.restResults$STATISTIC
p_value <- fa.restResults$PVAL
cat("Chi-Square:", chi_sq, "\nP-Value:", p_value, "\n")
CFI <- 1 - ((chi_sq - fa.restResults$dof) / (fa.restResults$null.chisq - fa.restResults$null.dof))
cat("CFI:", CFI, "\n")


# plot loadings (thresholded at 0.3)
plot_thresholded_loadings <- function(fa_result, threshold = 0.3, title = "EFA Loadings (Thresholded > absolute 0.3)") {
  # Extract loadings and prepare dataframe
  loadings_matrix <- as.data.frame(unclass(fa_result$loadings))
  colnames(loadings_matrix) <- paste0("Factor ", seq_len(ncol(loadings_matrix)))
  loadings_matrix$Item <- rownames(loadings_matrix)
  
  # Sort by first factor's loading
  first_comp <- colnames(loadings_matrix)[1]
  loadings_sorted <- loadings_matrix %>%
    arrange(desc(.data[[first_comp]]))
  
  # Apply threshold
  loadings_thresholded <- loadings_sorted %>%
    mutate(across(-Item, ~ ifelse(abs(.) < threshold, NA, .)))
  
  # Convert to long format
  loadings_long <- reshape2::melt(loadings_thresholded, id.vars = "Item",
                        variable.name = "Factor", value.name = "Loading")
  loadings_long <- na.omit(loadings_long)
  loadings_long$Item <- factor(loadings_long$Item, levels = loadings_sorted$Item)
  
  # Plot heatmap
  p <- ggplot(loadings_long, aes(x = Factor, y = Item, fill = Loading)) +
    geom_tile(color = "grey90") +
    scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = 0,
                         name = "Loading") +
    theme_minimal() +
    theme(
      axis.text.y = element_text(size = 10),
      axis.text.x = element_text(size = 10, face = "bold"),
      axis.title.x = element_text(size = 12, face = "bold"),
      axis.title.y = element_text(size = 12, face = "bold"),
      plot.title = element_text(size = 14, face = "bold"),
      panel.background = element_rect(fill = "white", colour = NA),
      plot.background = element_rect(fill = "white", colour = NA)
    ) +
    labs(title = title, x = "Factor", y = "Item") 
  print(p)
  
  #ggsave("~/Git/BodyWanderingCCA/figures/Indiv_Figures/ControlAnalyses/EFA/efa_loadings_thresholded.png", plot = p, width = 8, height = 6, dpi = 300)

}

# Plot thresholded loadings
plot_thresholded_loadings(fa.restResults, threshold = 0.3)

```

# EFA loading bar plot
```{r}

plot_loadings_bar <- function(fa_result, threshold = 0, title = "Exploratory Factor Analysis") {
  # Extract and prepare loadings
  loadings_matrix <- as.data.frame(unclass(fa_result$loadings))
  colnames(loadings_matrix) <- paste0("Factor ", seq_len(ncol(loadings_matrix)))
  loadings_matrix$Item <- rownames(loadings_matrix)
  
  # Identify factor columns
  factor_cols <- grep("^Factor", colnames(loadings_matrix), value = TRUE)
  
  # Order items by Factor 1 loadings (descending)
  loadings_matrix <- loadings_matrix %>% arrange(desc(`Factor 1`))
  
  # Reshape to long format
  loadings_long <- loadings_matrix %>%
    pivot_longer(cols = all_of(factor_cols),
                 names_to = "Factor",
                 values_to = "Loading")
  
  # Apply threshold
  loadings_long <- loadings_long %>%
    mutate(Loading_thresholded = ifelse(abs(Loading) >= threshold, Loading, NA)) %>%
    drop_na(Loading_thresholded)
  
  # Preserve item order (by Factor 1)
  loadings_long$Item <- factor(loadings_long$Item, 
                               levels = unique(loadings_matrix$Item))
  
  # Determine symmetric range for colour scaling
  rng <- max(abs(loadings_long$Loading_thresholded), na.rm = TRUE)
  
  # Plot
  p <- ggplot(loadings_long, aes(x = Item, 
                                 y = Loading_thresholded,
                                 fill = Loading_thresholded)) +
    geom_bar(stat = "identity", position = "identity", width = 0.7,
             colour = "grey35", linewidth = 0.2) +  # <-- outline added
    geom_hline(yintercept = c(0.3, -0.3), linetype = "dashed", colour = "grey60", linewidth = 0.6) +
    facet_wrap(~ Factor, scales = "free_x", nrow = 1) +
    coord_flip() +
    scale_fill_gradient2(
      low = "blue",
      mid = "white",
      high = "red",
      midpoint = 0,
      limits = c(-rng, rng),
      name = "Loading"
    ) +
    labs(title = title, x = "Mind-Wandering Item", y = "Loading (Pattern Coefficient)") +
    theme_minimal() +
    theme(
      axis.text.y = element_text(size = 9),
      axis.title.x = element_text(size = 11, face = "bold"),
      axis.title.y = element_text(size = 11, face = "bold"),
      strip.text = element_text(size = 12, face = "bold"),
      plot.title = element_text(size = 14, face = "bold", hjust = 0.5),
      legend.position = "bottom",
      panel.grid.major.y = element_blank()
    )
  
  print(p)
  
  # Optionally save
  ggsave("~/Git/BodyWanderingCCA/figures/Indiv_Figures/ControlAnalyses/EFA/efa_loadings_barplot.png",
         plot = p, width = 10, height = 6, dpi = 300)
}

# call
plot_loadings_bar(fa.restResults, threshold = 0)

```


# EFA loading table
```{r}

library(psych)
library(knitr)
library(kableExtra)
library(dplyr)

# Assume fa.restResults is the EFA result from fa(..., rotate = "oblimin")
# Extract the loadings matrix and convert to a data frame
loadings_df <- as.data.frame(unclass(fa.restResults$loadings))
loadings_df$Item <- rownames(loadings_df)

# Reorder columns so that "Item" is first
loadings_df <- loadings_df[, c("Item", setdiff(names(loadings_df), "Item"))]
rownames(loadings_df) <- NULL
colnames(loadings_df) <- c('Item', 'Factor 1', 'Factor 2')

# Define threshold value
threshold <- 0.3

# Format loadings: 
# - Bold for values ≥ |0.3|
# - Light grey for values < |0.3|
formatted_loadings <- loadings_df %>%
  mutate(across(-Item, ~ ifelse(abs(.) >= threshold, 
                                cell_spec(round(., 2), format = "html", bold = TRUE), 
                                cell_spec(round(., 2), format = "html", color = "gray"))))

# Create and display the formatted table
kable(formatted_loadings, format = "html", escape = FALSE, caption = "EFA Loadings (Thresholded at |0.3|)") %>%
  kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover"))


```

# robustness of EFA
```{r}

run_efa_pipeline <- function(data, label = "Dataset") {
  
  # Compute correlation matrix (polychoric)
  cormatrix <- hetcor(data)$correlations
  sample_size <- nrow(data)
  
  # Run EFA
  fa_result <- fa(
    cormatrix, 
    nfactors = 2, # MAP 
    n.obs = sample_size,
    rotate = "oblimin",
    max.iter = 500,
    fm = "pa"
  )
  print(fa_result)
  fa.diagram(fa_result)
  
  # Fit indices
  chi_sq <- fa_result$STATISTIC
  p_value <- fa_result$PVAL
  cat("Chi-Square:", chi_sq, "\nP-Value:", p_value, "\n")
  CFI <- 1 - ((chi_sq - fa_result$dof) / (fa_result$null.chisq - fa_result$null.dof))
  cat("CFI:", CFI, "\n")
  
  # Plot thresholded loadings
  plot_thresholded_loadings(fa_result, threshold = 0.3, title = paste("Loadings (", label, ")", sep = ""))
  
  return(fa_result)
}

# split into odd & even rows
rest_probes_odd <- rest_probes[seq(1, nrow(rest_probes), by = 2), ]
rest_probes_even <- rest_probes[seq(2, nrow(rest_probes), by = 2), ]

# Run EFA on both datasets
fa_odd <- run_efa_pipeline(rest_probes_odd, label = "Odd-indexed Rows")
fa_even <- run_efa_pipeline(rest_probes_even, label = "Even-indexed Rows")


# Compare correlations of factor loadings across even and odd split

# Correlation of loadings on each factor across splits
cor_factor1 <- cor(fa_even$loadings[,1], fa_odd$loadings[,1])
cor_factor2 <- cor(fa_even$loadings[,2], fa_odd$loadings[,2])

cat("Factor 1 loading correlation:", round(cor_factor1, 3), "\n")
cat("Factor 2 loading correlation:", round(cor_factor2, 3), "\n")

```


# Correlate factors-connectivity results with CCA variate
```{r}

# factor connectivity univariate correlations result with CCA brain loadings
factor1connect <- read_csv('~/Git/BodyWanderingCCA/data/FactorConnectivity/Factor1connect_massunivariateresults.csv')$t_score
factor2connect <- read_csv('~/Git/BodyWanderingCCA/data/FactorConnectivity/Factor2connect_massunivariateresults.csv')$t_score
cca_brainloadings <- readMat('~/Git/BodyWanderingCCA/figures/Indiv_Figures/CCA/CCAloadings/Connectome/brainloadings.mat')$weightX

cordata <- cbind(factor1connect, factor2connect, cca_brainloadings)
colnames(cordata) <- c('Factor1.UniVar.Connect.Corr', 'Factor2.UniVar.Connect.Corr', 'CCA.brain.loadings')
cormatrix_full(cordata, 'factor & cca loading correlations', 'Spearman correlations')
psych::corr.test(cordata, method = "spearman", adjust = "fdr")$p


# permuted p-values via 10000 permuations
perm_rho_fact1 <- replicate(10000, cor(sample(cordata[ ,'CCA.brain.loadings']),
                                 cordata[ ,'Factor1.UniVar.Connect.Corr'],
                                 method = "spearman"))
emp_p_fact1 <- mean(abs(perm_rho_fact1) >= abs(cor(cordata[ ,'CCA.brain.loadings'], cordata[ ,'Factor1.UniVar.Connect.Corr'],method = "spearman")))


perm_rho_fact2 <- replicate(10000, cor(sample(cordata[ ,'CCA.brain.loadings']),
                                 cordata[ ,'Factor2.UniVar.Connect.Corr'],
                                 method = "spearman"))
emp_p_fact2 <- mean(abs(perm_rho_fact2) >= abs(cor(cordata[ ,'CCA.brain.loadings'], cordata[ ,'Factor2.UniVar.Connect.Corr'],method = "spearman")))

# plot scatter
library(ggplot2)
library(psych)
library(patchwork)

make_plot <- function(xvar, label) {
  cor_res <- corr.test(cordata[, xvar], cordata[, 'CCA.brain.loadings'], method = "spearman")
  rho <- round(cor_res$r, 3)
  r2 <- round(rho^2, 3)
  #p <- ifelse(cor_res$p < 0.001, "< 0.001", signif(cor_res$p, 3))
  
  ggplot(cordata, aes_string(xvar, "CCA.brain.loadings")) +
    geom_point(colour = "slateblue4", alpha = 0.15, size = 0.8) +
    geom_smooth(method = "lm", se = FALSE, linetype = "dashed", colour = "grey40", linewidth = 0.6) +
    theme_classic() +
    labs(
      x = paste(label, "connectivity coefficients"),
      y = "CCA brain loadings",
      title = paste0("r\u209B = ", rho, " (r\u209B² = ", r2, ")")#, p ", p)
    )
}

p1 <- make_plot("Factor1.UniVar.Connect.Corr", "Factor 1")
p2 <- make_plot("Factor2.UniVar.Connect.Corr", "Factor 2")

(p1 + p2)

ggsave("~/Git/BodyWanderingCCA/figures/revisionplots_all/Corr_Factorconnect_CCAconnectloadings.png",
       p1 + p2, width = 10, height = 4, dpi = 300)


```

```{r}
# hex plot
library(ggplot2)
library(psych)
# install.packages("hexbin")   # run once if you don't have it

make_hex_plot <- function(xvar, label) {
  cor_res <- corr.test(cordata[, xvar], cordata[, 'CCA.brain.loadings'], method = "spearman")
  rho <- round(cor_res$r, 3)
  r2  <- round(rho^2, 3)
  
  ggplot(cordata, aes_string(xvar, "CCA.brain.loadings")) +
    geom_hex(bins = 40) +  # adjust bins if you want coarser/finer hexes
    geom_smooth(method = "lm", se = FALSE, linetype = "dashed",
                colour = "grey20", linewidth = 0.6) +
    scale_fill_gradient(name = "Count", low = "#ebf3f7", high = "slateblue4") +
    theme_classic() +
    labs(
      x = paste(label, "connectivity coefficients"),
      y = "CCA brain loadings",
      title = paste0("r\u209B = ", rho, " (r\u209B² = ", r2, ")")
    )
}

p1_hex <- make_hex_plot("Factor1.UniVar.Connect.Corr", "Factor 1")
p2_hex <- make_hex_plot("Factor2.UniVar.Connect.Corr", "Factor 2")

(p1_hex + p2_hex)

ggsave("~/Git/BodyWanderingCCA/figures/revisionplots_all/Corr_Factorconnect_CCAconnectloadings_hexplot5.png",
       p1_hex + p2_hex, width = 10, height = 4, dpi = 300)


```


# Factor scores with mental health & arousal metrics
```{r}

# factor scores EFA
factor_scores<-factor.scores(rest_probes, fa.restResults, method = "Bartlett")
factor_scores<-as.data.frame(factor_scores$scores)
colnames(factor_scores) <- c('Factor 1', 'Factor 2')

# Combine subids with factor_scores & save csv
#write.csv(data.frame(subids = subids, factor_scores), "~/Git/BodyWanderingCCA/data/EFAscores.csv", row.names = FALSE)

# subids <- read_tsv("/home/leah/Git/BodyWanderingCCA/data/mindwand_movieratings.tsv")
# subids[subids == "n/a"] <- NA 
# subids <- subids[complete.cases(subids$RS_MW_1), 'participant_id']
# alldata <- read_csv("~/Git/body_wandering/data/BodyWanderingData.csv")$participant_id
# check order of participants in alldata is same participant order in efa scores
#identical(alldata$participant_id, subids$participant_id)

# Psych & Physio together (to correct multiple comparisons)
alldata <- read_csv("~/Git/body_wandering/data/BodyWanderingData.csv")
cols = c("asrs.combined.sum", "mdi", "Heart Rate", "HRV RMSSD", "High Freq Power", "LF/HF Ratio", "Resp Rate", "Resp Duration Mean", "Resp Duration SD", "Resp Depth Mean", "Resp Depth SD", "Gastric Peak Freq", "Gastric Max Power", "Gastric Prop Power")
alldata <- alldata[complete.cases(alldata[, c("Future")]), ][ ,cols] #NAs in Future is same as all mind-wandering item

# merge data
corrdata <- cbind(factor_scores, alldata) 

col2log <- c("mdi", "HRV RMSSD", "LF/HF Ratio", "Resp Duration SD", "Resp Depth SD", "Gastric Max Power")
for (col in col2log) {
  corrdata[ ,col] <- log(corrdata[ ,col] + 1)
}
corrdata[,3:ncol(corrdata)] <- corrdata[,3:ncol(corrdata)] %>% mutate_if(is.numeric, ~ifelse(abs(. - mean(., na.rm = TRUE)) > 3 * sd(., na.rm = TRUE), NA, .)) # remove outliers


# make bar also
library(tidyr)
library(dplyr)

# Correlation plots
cormatrix <- t(psych::corr.test(corrdata, method = "spearman", adjust = "fdr")$r[1:2, 3:16])#[2:3, 6:19]
cor_pvals <- t(psych::corr.test(corrdata, method = "spearman", adjust = "fdr")$p[1:2, 3:16])
cor_pvals[cor_pvals > 0.05] <- NA 

cormatrix <- as.data.frame(cormatrix)
cormatrix$Vars <- rownames(cormatrix)

# Convert to long format
cormatrix<- cormatrix %>%
  pivot_longer(cols = -Vars, names_to = "Correlation", values_to = "Value") %>%
  mutate(Vars = factor(Vars, levels = unique(Vars))) # Ensure the order is as desired


# Step 1: Create a sorting frame based on positive correlations
sort_order <- cormatrix %>%
  dplyr::filter(Correlation == "Factor 1") %>%
  dplyr::arrange(desc(Value)) %>%
  dplyr::mutate(order = row_number()) %>%
  dplyr::select(Vars, order) # Adjusted to ensure select is correctly applied

# Step 2: Merge this order back into the original dataset
cormatrix <- cormatrix %>%
  left_join(sort_order, by = "Vars") %>%
  mutate(Vars = factor(Vars, levels = sort_order$Vars)) # Reorder based on positive correlation

# Step 3: Plot the data
plot <- ggplot(cormatrix, aes(x = Vars, y = Value, fill = Correlation)) +
  geom_col(position = position_dodge2(padding = 0.2), width = 1) +
  coord_flip() +
  theme_minimal() +
  scale_fill_manual(values = c("Factor 1"= "coral", "Factor 2" = "deepskyblue")) +
  labs(y = "Spearman Coefficient", title = "Mind-Wandering Correlations") +
  theme(
    axis.title.y = element_text(size = 16),
    axis.title.x = element_text(size = 16),
    axis.text.y = element_text(size = 16, margin = margin(t = 0, r = 0, b = 0, l = 10, unit = "pt")),
    axis.text.x = element_text(size = 16, margin = margin(t = 0, r = 0, b = 10, l = 0, unit = "pt")),
    legend.text = element_text(size = 16),
    legend.title = element_text(size = 15),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.background = element_blank(),
    axis.line = element_line(colour = "black")
  )

print(plot)

# Save the plot with specified dimensions
ggsave("~/Git/BodyWanderingCCA/figures/Indiv_Figures/ControlAnalyses/EFA/EFAfactors_correlations_all.png", plot, width = 11, height = 8, dpi = 300, bg = 'white')

```


# CCA variates with mental health & arousal metrics
```{r}
library(R.matlab)

# CCA variates
BW_item_variate <- readMat("~/Git/body_wandering/figures/CCA/Abend216/BWitems/CCAvariate.mat")$P
colnames(BW_item_variate) <- c('CCA.brain.variate', 'CCA.beh.variate')
BWCCAs_subIDs <- readMat("~/Git/body_wandering/data/CCA_input/subIDs_BWCCAs.mat")$subIDs


# Psych & Physio together (to correct multiple comparisons)
alldata <- read_csv("~/Git/body_wandering/data/BodyWanderingData.csv")
cols = c("participant_id", "asrs.combined.sum", "mdi", "Heart Rate", "HRV RMSSD", "High Freq Power", "LF/HF Ratio", "Resp Rate", "Resp Duration Mean", "Resp Duration SD", "Resp Depth Mean", "Resp Depth SD", "Gastric Peak Freq", "Gastric Max Power", "Gastric Prop Power")
col2log <- c("mdi", "HRV RMSSD", "LF/HF Ratio", "Resp Duration SD", "Resp Depth SD", "Gastric Max Power")
for (col in col2log) {
  corrdata[ ,col] <- log(corrdata[ ,col] + 1)
}
corrdata[,3:ncol(corrdata)] <- corrdata[,3:ncol(corrdata)] %>% mutate_if(is.numeric, ~ifelse(abs(. - mean(., na.rm = TRUE)) > 3 * sd(., na.rm = TRUE), NA, .)) # remove outliers
alldata <- alldata[complete.cases(alldata[, c("Future")]), ][ ,cols] #NAs in Future is same as all mind-wandering item

# match and merge the relevant variables of interest
match_merge <- function(data1, data2, subIDs1, subIDs2, labels) {
  reorder_idx <- match(subIDs1, subIDs2)
  data2 <- data2[reorder_idx, ]

  # merge data across dataframes
  merged <- cbind(data1, data2)
  colnames(merged) <- labels
  return(merged)
}

CCAvar_corr <- match_merge(BW_item_variate, alldata[ 2:ncol(alldata)], BWCCAs_subIDs, as.numeric(sub("sub-", "", alldata$participant_id)), c(colnames(BW_item_variate), colnames(alldata[ 2:ncol(alldata)])))


# make bar also
library(tidyr)
library(dplyr)

# Correlation plots
cormatrix <- t(psych::corr.test(CCAvar_corr, method = "spearman", adjust = "fdr")$r[1:2, 3:16])#[2:3, 6:19]
cor_pvals <- t(psych::corr.test(CCAvar_corr, method = "spearman", adjust = "fdr")$p[1:2, 3:16])
cor_pvals[cor_pvals > 0.05] <- NA 

cormatrix <- as.data.frame(cormatrix)
cormatrix$Vars <- rownames(cormatrix)

# Convert to long format
cormatrix<- cormatrix %>%
  pivot_longer(cols = -Vars, names_to = "Correlation", values_to = "Value") %>%
  mutate(Vars = factor(Vars, levels = unique(Vars))) # Ensure the order is as desired


# Step 1: Create a sorting frame based on positive correlations
sort_order <- cormatrix %>%
  dplyr::filter(Correlation == "CCA.beh.variate") %>%
  dplyr::arrange(desc(Value)) %>%
  dplyr::mutate(order = row_number()) %>%
  dplyr::select(Vars, order) # Adjusted to ensure select is correctly applied

# Step 2: Merge this order back into the original dataset
cormatrix <- cormatrix %>%
  left_join(sort_order, by = "Vars") %>%
  mutate(Vars = factor(Vars, levels = sort_order$Vars)) # Reorder based on positive correlation

# Step 3: Plot the data
plot <- ggplot(cormatrix, aes(x = Vars, y = Value, fill = Correlation)) +
  geom_col(position = position_dodge2(padding = 0.2), width = 1) +
  coord_flip() +
  theme_minimal() +
  scale_fill_manual(values = c("CCA.beh.variate"= "mediumslateblue", "CCA.brain.variate" = "hotpink")) +
  labs(y = "Spearman Coefficient", title = "Mind-Wandering Correlations") +
  theme(
    axis.title.y = element_text(size = 16),
    axis.title.x = element_text(size = 16),
    axis.text.y = element_text(size = 16, margin = margin(t = 0, r = 0, b = 0, l = 10, unit = "pt")),
    axis.text.x = element_text(size = 16, margin = margin(t = 0, r = 0, b = 10, l = 0, unit = "pt")),
    legend.text = element_text(size = 16),
    legend.title = element_text(size = 15),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.background = element_blank(),
    axis.line = element_line(colour = "black")
  )

print(plot)

# Save the plot with specified dimensions
ggsave("~/Git/BodyWanderingCCA/figures/Indiv_Figures/ControlAnalyses/MWaverage_corr/CCAvariate_correlations_all.png", plot, width = 11, height = 8, dpi = 300, bg = 'white')

```
