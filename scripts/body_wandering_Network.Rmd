
**Import post-resting-state mind-wandering data**
```{r, message=FALSE}

# clean slate to be sure
rm(list = ls())

# check for pacman package and install if not found
if (!require("pacman")) install.packages("pacman")
  pacman::p_load(readr,psych,polycor,corrplot,lattice,nFactors,GPArotation,EFA.dimensions,dplyr, tidyverse, here, circlize, BiocManager, ComplexHeatmap, gplots, gridExtra, gt, kableExtra, ggcorrplot, R.matlab, EFAtools, moments)

# load probe data 
probe_data <- read_tsv(here("data", "mindwand_movieratings.tsv")) 

# select post-restingstate mindwandering responses only
rest_probes <- probe_data %>%
  select(-starts_with("RS_MW_RT")) %>%
  select(-starts_with("MOV_MW_RT")) %>%
  select(starts_with("RS_MW"))
 
rest_probes[rest_probes == "n/a"] <- NA # NA's in correct format #rest_probes <- na.omit(rest_probes) # remove NA's
rest_probes <- apply(as.matrix(rest_probes), 2, as.numeric) #convert to numeric matrix
rest_probes <- na.omit(rest_probes)

hist(rest_probes)

# # # Get demographic summary stats
# demographic_data <- read_tsv("/home/leah/R/survey_pipelines_R/summary_data/BIDS_data/demographics_basic_ques.tsv")
# demographic_data[demographic_data == "n/a"] <- NA
# # age stats:
# mean(as.numeric(unlist(demographic_data["age"])),na.rm=TRUE)
# sd(as.numeric(unlist(demographic_data["age"])),na.rm=TRUE)
# min(as.numeric(unlist(demographic_data["age"])),na.rm=TRUE)
# max(as.numeric(unlist(demographic_data["age"])),na.rm=TRUE)
# # gender counts:
# sum(as.numeric(unlist(demographic_data["gender"])) == 1,na.rm=TRUE) # woman
# sum(as.numeric(unlist(demographic_data["gender"])) == 2,na.rm=TRUE) # man
# sum(as.numeric(unlist(demographic_data["gender"])) == 3,na.rm=TRUE) # other

```

**Variable Key**
```{r}

#load the MW probe key
MW_rest_key <- read_csv(here("data", "probe_key.csv"))
colnames(rest_probes) = MW_rest_key$Label

#write.csv(rest_probes,here("data", "mw_rest_probes.csv"))
```


**Test assumptions of rest mind-wandering data**
```{r}

sample_size = nrow(rest_probes)-nrow(rest_probes[which(is.na(rest_probes[,1])),])

# Correlation plots
cormatrix = hetcor(rest_probes)$correlations
corrplot(cormatrix, method="circle", addrect = 0,
         title = "RestProbes", mar = c(0,0,1,0),tl.cex=0.9) 

#png(filename = here("figures/Item_response_plots", "heatmap_itemcorr.png"), res = 150, height = 12, width = 12, units = "cm")
# Heatmap of correlations
stats::heatmap(hetcor(rest_probes)$correlations,cexRow=0.8,cexCol=0.8)
#dev.off()

# Bartlett’s Test of Sphericity (relationship strength/multivariate normality)
# ^statistically significant chi-square value 
cortest.bartlett(cormatrix,sample_size)

# Kaiser-Meyer-Olkin test for sampling adequacy
# Overall KMO values ≥.70 are desired, values less than .50 are generally considered unacceptable
KMO(cormatrix)

# remove spontaneous as KMO <.5
rest_probes = subset(rest_probes, select = -c(Spontaneous))
KMO(hetcor(rest_probes)$correlations) # KMO again once spontaneous removed
cortest.bartlett(hetcor(rest_probes)$correlations,sample_size)

## Test for the assumption of normality
skewness(na.omit(rest_probes))
kurtosis(na.omit(rest_probes))

# Internal Reliability of MDIES
psych::alpha(rest_probes, check.keys=TRUE)
omega(rest_probes)

```


# Network analysis
```{r}
library("bootnet")
library("ggplot2")
library("qgraph")

# remove NA subjects
rest_probes <- rest_probes[complete.cases(rest_probes), ]

# Network Estimation: estimate a Gaussian graphical model, using the graphical LASSO in combination with EBIC model selection
# This procedure requires an estimate of the variance-covariance matrix and returns a parsimonious network of partial correlation coefficients.
Network <- estimateNetwork(rest_probes, default = "EBICglasso")
plot(Network, layout = "spring")

# Compute Centrality indices
png(filename = here("figures", "network_centrality_indices.png"), res = 150, height = 12, width = 20, units = "cm")
centralityPlot(Network, include="all")
dev.off()
clusteringPlot(Network)


# Edge-weight accuracy (bootstrapping)
boot1 <-bootnet(Network,statistics= c("edge","strength","closeness","betweenness","expectedInfluence"), nBoots = 2500, nCores = 8)
print(boot1)
summary(boot1)
png(filename = here("figures", "network_edgeweight_acc.png"), res = 150, height = 12, width = 20, units = "cm")
plot(boot1, statistics = "edge", labels = FALSE, order = "sample")
dev.off()

# Centrality stability
boot2 <- bootnet(Network, statistics= c("strength","closeness","betweenness","expectedInfluence"), nBoots = 2500, type = "case", nCores = 8)
png(filename = here("figures", "network_centrality_stability.png"), res = 150, height = 12, width = 20, units = "cm")
plot(boot2, statistics= c("strength","closeness","betweenness","expectedInfluence"))
dev.off()
corStability(boot2)

# Testing for significant differences
differenceTest(boot1, 5, 17,"strength") # 5=Pos & 17=Heart for example

png(filename = here("figures", "network_sig_edge.png"), res = 150, height = 20, width = 20, units = "cm")
plot(boot1, "edge", plot = "difference", onlyNonZero = TRUE, order = "sample")
dev.off()
png(filename = here("figures", "network_sig_strength.png"), res = 150, height = 12, width = 20, units = "cm")
plot(boot1, "strength")
dev.off()
png(filename = here("figures", "network_sig_closeness.png"), res = 150, height = 12, width = 20, units = "cm")
plot(boot1, "closeness")
dev.off()
png(filename = here("figures", "network_sig_betweenness.png"), res = 150, height = 12, width = 20, units = "cm")
plot(boot1, "betweenness")
dev.off()
png(filename = here("figures", "network_sig_expectedinfluence.png"), res = 150, height = 12, width = 20, units = "cm")
plot(boot1, "expectedInfluence")
dev.off()

```


```{r}
library(igraph)
#-----------------------------#
##### COMMUNITY DETECTION #####
#-----------------------------#

#spin-glass algorithm for community detection ----#
matrix<- graph.adjacency(Network$graph, mode="upper", diag=FALSE, weighted=TRUE)
set.seed(123)

community_OKI <- spinglass.community(matrix, weights=NULL, vertex=NULL, spins=21, parupdate=FALSE, start.temp=1, stop.temp=0.01, cool.fact=0.99, update.rule="simple", gamma=1, implementation="neg",gamma.minus=1)


#given the presence of negative edges in the glasso, we used the "neg"
#implementation the gamma and gamma.minus were set at 1 to makes existing and
#non-existing links equally important the number of spins was set to 21 as the
#upper limit for the number of communities is 21 in the present case (i.e., 21
#community would mean that each node possesses its own community)

community_OKI
community_OKI$membership
community_OKI$csize

# Create a color palette based on the unique values in the community membership
unique_communities <- unique(community_OKI$membership)
#color_palette <- c("aquamarine", "khaki1", "lightblue1", "thistle1", "lightsalmon")  # Add more colors if needed
color_palette <- c("khaki1", "lightsalmon", "aquamarine", "thistle1", "lightblue1") 
community_colors <- color_palette[match(community_OKI$membership, unique_communities)]


# # Plot the graph with automatic color assignment
# png(filename = here("figures", "network_plot_rest_communities.png"), res = 150, height = 12, width = 15, units = "cm")
# GGM_figure_FINAL <- qgraph(Network, groups = community_OKI$membership,
#                            color = community_colors, layout = 'spring',  
#                            vsize = 7.5, border.width = 2,
#                            details = FALSE, labels = colnames(rest_probes),
#                            label.scale.equal = TRUE, 
#                            color = '#bbbbbb', border.width = 4, 
#                            edge.labels = FALSE, legend = FALSE, posCol= 'indianred1', negCol = 'steelblue1')
# 
# dev.off()

png(filename = here("figures", "network_plot_rest_communities.png"), res = 150, height = 12, width = 12, units = "cm")
plot(Network, layout = "spring",groups=community_OKI$membership, color = community_colors, posCol= 'brown2', negCol = 'royalblue2')
dev.off()


# # Define labels for community detection
# labels <- c("Breath, Temporality, Imagery & Focus", "Positive, Personhood & Ruminate", "Negative Internal", "Vivid Distance", "Body & Movement")
# plot(Network, layout = "spring",groups=community_OKI$membership, color = community_colors, posCol= 'brown2', negCol = 'royalblue2')
# legend("topright", legend = labels, col = color_palette, pch = 16)


# Test the reliability of factors
psych::alpha(rest_probes[ , c("Neg", "Bladder", "Heart", "Arousal", "Skin", "Stomach")], check.keys=TRUE)
psych::alpha(rest_probes[ , c("Breath", "Vague", "Focus", "Past", "Future", "Image", "Vague")], check.keys=TRUE)
psych::alpha(rest_probes[ , c("Pos", "Other", "Self", "Words", "Ruminate")], check.keys=TRUE)
psych::alpha(rest_probes[ , c("Distant", "Vivid")], check.keys=TRUE)
psych::alpha(rest_probes[ , c("Body", "Movement")], check.keys=TRUE)

```


# Control Averages of Network Communities
```{r}
rest_probes <- read_csv('~/Git/BodyWanderingCCA/data/rest_probes.csv')[ ,2:23]
rest_probes = subset(rest_probes, select = -c(Spontaneous))
# average items in network communities
subject_community_scores <- data.frame(Subject = seq_len(nrow(rest_probes)))
community_membership <- membership(community_OKI)
names(community_membership) <- colnames(rest_probes)
# Loop through each community and compute subject-level scores
for (comm in unique(community_membership)) {
  items_in_community <- names(community_membership[community_membership == comm])
  print(items_in_community)
  subject_community_scores[[paste0("Community_", comm)]] <- rowMeans(rest_probes[, items_in_community, drop=FALSE], na.rm=TRUE)
}
colnames(subject_community_scores) <- c("Subject", "BreathTemporalityImageryFocus", "PositivePersonhoodRuminate", "NegativeInternal", "VividDistance", "BodyMovement")


# Psych & Physio together (to correct multiple comparisons)
alldata <- read_csv("~/Git/body_wandering/data/BodyWanderingData.csv")
cols = c("asrs.combined.sum", "mdi", "Heart Rate", "HRV RMSSD", "High Freq Power", "LF/HF Ratio", "Resp Rate", "Resp Duration Mean", "Resp Duration SD", "Resp Depth Mean", "Resp Depth SD", "Gastric Peak Freq", "Gastric Max Power", "Gastric Prop Power")
alldata <- alldata[complete.cases(alldata[, c("Future")]), ][ ,cols] #NAs in Future is same as all mind-wandering item
corrdata <- cbind(subject_community_scores[ ,2:6], alldata) 
col2log <- c("mdi", "HRV RMSSD", "LF/HF Ratio", "Resp Duration SD", "Resp Depth SD", "Gastric Max Power")
for (col in col2log) {
  corrdata[ ,col] <- log(corrdata[ ,col] + 1)
}
corrdata[,3:ncol(corrdata)] <- corrdata[,3:ncol(corrdata)] %>% mutate_if(is.numeric, ~ifelse(abs(. - mean(., na.rm = TRUE)) > 3 * sd(., na.rm = TRUE), NA, .)) # remove outliers

#cormatrix_full(corrdata, "Body-Wandering Averages", "Community Averages & Physio Metric Correlations")
#cormatrix_selected(corrdata, "Body-Wandering Averages", "Physio Metrics", 5, 14, here::here("figures", "corr_MWcommunities_PsychPhysio.png"))


# make bar also
library(tidyr)
library(dplyr)

# Correlation plots
cormatrix <- t(psych::corr.test(corrdata, method = "spearman", adjust = "fdr")$r[1:5, 6:19])#[2:3, 6:19]
cor_pvals <- t(psych::corr.test(corrdata, method = "spearman", adjust = "fdr")$p[1:5, 6:16])
cor_pvals[cor_pvals > 0.05] <- NA 

cormatrix <- as.data.frame(cormatrix)
cormatrix$Vars <- rownames(cormatrix)

# Convert to long format
cormatrix<- cormatrix %>%
  pivot_longer(cols = -Vars, names_to = "Correlation", values_to = "Value") %>%
  mutate(Vars = factor(Vars, levels = unique(Vars))) # Ensure the order is as desired


# Step 1: Create a sorting frame based on positive correlations
sort_order <- cormatrix %>%
  dplyr::filter(Correlation == "NegativeInternal") %>%
  dplyr::arrange(desc(Value)) %>%
  dplyr::mutate(order = row_number()) %>%
  dplyr::select(Vars, order) # Adjusted to ensure select is correctly applied

# Step 2: Merge this order back into the original dataset
cormatrix <- cormatrix %>%
  left_join(sort_order, by = "Vars") %>%
  mutate(Vars = factor(Vars, levels = sort_order$Vars)) # Reorder based on positive correlation

# Step 3: Plot the data
plot <- ggplot(cormatrix, aes(x = Vars, y = Value, fill = Correlation)) +
  geom_col(position = position_dodge2(padding = 0.2), width = 1) +
  coord_flip() +
  theme_minimal() +
  scale_fill_manual(values = c("BreathTemporalityImageryFocus"= "khaki1", "PositivePersonhoodRuminate" = "lightsalmon", "NegativeInternal"= "aquamarine", "VividDistance" ="thistle1", "BodyMovement"= "lightblue1")) +
  labs(y = "Spearman Coefficient", title = "Mind-Wandering Correlations") +
  theme(
    axis.title.y = element_text(size = 16),
    axis.title.x = element_text(size = 16),
    axis.text.y = element_text(size = 16, margin = margin(t = 0, r = 0, b = 0, l = 10, unit = "pt")),
    axis.text.x = element_text(size = 16, margin = margin(t = 0, r = 0, b = 10, l = 0, unit = "pt")),
    legend.text = element_text(size = 16),
    legend.title = element_text(size = 15),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.background = element_blank(),
    axis.line = element_line(colour = "black")
  )

print(plot)

# Save the plot with specified dimensions
ggsave(here::here("figures", "BWcommunities_correlations_all.png"), plot, width = 11, height = 8, dpi = 300, bg = 'white')


```


